<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nearest Match</title>
    <link rel="stylesheet" href="https://unpkg.com/css-baseline/css/3.css">
    <link rel="stylesheet" href="https://cdn.skypack.dev/gridjs@6.0.6//dist/theme/mermaid.css">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Roboto');
        @import url('https://fonts.googleapis.com/css2?family=Roboto:wght@100&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Roboto:wght@300&display=swap');
        :root {
            --gray-pallet-background: rgb(30, 37, 53);
            --red-pallet-background: lightcoral;
            --off-white: hsl(0, 0%, 87.8%);
            --charcoal: hsl(180, 0%, 31%);
            --charcoal-on-charcoal: hsl(0deg 0% 50%);
            --soft-gray-gradient: linear-gradient(-110deg, whitesmoke, var(--off-white));
            /* misc */
            --red-pallet-font: white;
            --decent-color-1: lightcoral;
            --decent-color-2: salmon;
            --decent-color-3: lightpink;
            --decent-color-4: lightsalmon;
            --decent-color-5: coral;
            --decent-color-6: lightcyan;
            --decent-color-7: lightblue;
            --decent-color-8: lightsteelblue;
            --decent-color-9: skyblue;
            --decent-color-10: lightskyblue;
            --decent-color-11: cornflowerblue;
            --decent-color-12: dodgerblue;
            --decent-color-13: aquamarine;
            --decent-color-14: turquoise;
            --decent-color-15: darkturquoise;
            --decent-color-16: lightseagreen;
            --decent-color-17: darkcyan;
            --decent-color-18: teal;
            --decent-color-19: mediumspringgreen;
            --decent-color-20: lightgreen;
            --decent-color-21: cadetblue;
            --decent-color-22: darkorchid;
            --decent-color-23: blueviolet;
        }
        body {
            font-size: 0.9em;
            font-family: Roboto;
        }
        .animate {
            transition: all 0.5s ease-in-out 0s;
        }
        .weak-shadow {
            transition: all 0.3s ease-in-out 0s;
            box-shadow: 0 4px 5px 0 rgba(0,0,0,0.10),0 1px 10px 0 rgba(0,0,0,0.08),0 2px 4px -1px rgba(0,0,0,0.24);
        }
        .weak-shadow:hover {
            box-shadow: 0 8px 17px 2px rgba(0,0,0,0.10),0 6px 30px 5px rgba(0,0,0,0.08),0 8px 10px -7px rgba(0,0,0,0.16);
        }
        button {
            border-radius: 1em;
            border: none;
            background-color: cornflowerblue;
            padding: 0.5em 1em;
            color: white;
        }
        a {
            color: lightskyblue;
            text-decoration: underline;
        }
        span {
            vertical-align: text-top;
        }
    </style>
</head>
<!--                                   -->
<!-- Synchonous/Fast loading animation -->
<!--                                   -->
    <body>
        <div style="display: flex;justify-content: center;align-items: center;height: 100vh;">
            <div style="width: 50px;height: 50px;border: 10px solid #dddddd;border-top-color: #009579;border-radius: 50%;transform: rotate(0.16turn);" id="good-component--initial-loader">
            </div>
        </div>
    </body>
    <script>
        // 
        // Synchonous/Fast loading animation
        // 
            const animateLoader = ()=>{
                const element = document.getElementById("good-component--initial-loader")
                element && element.animate(
                    [
                        { transform: 'rotate(0turn)' },
                        { transform: 'rotate(1turn)' },
                    ],
                    {
                        duration: 1000,
                        iterations: Infinity,
                        easing: 'ease',
                    },
                )
            }
            document.body ? animateLoader() : document.addEventListener("DOMContentLoaded", animateLoader)
    </script>

<!--              -->
<!-- Elementalist -->
<!--              -->
<script type="module">
    import { toString } from "https://deno.land/x/good@1.4.4.3/string.js"
    import { allKeyDescriptions, } from 'https://deno.land/x/good@0.7.8/value.js'
        // minimized xhtm from: https://github.com/dy/xhtm
        const FIELD = "\ue000",
            QUOTES = "\ue001"

        function htm(statics) {
            let h = this,
                prev = 0,
                current = [null],
                field = 0,
                args,
                name,
                value,
                quotes = [],
                quote = 0,
                last,
                level = 0,
                pre = false

            const evaluate = (str, parts = [], raw) => {
                let i = 0
                str = !raw && str === QUOTES ? quotes[quote++].slice(1, -1) : str.replace(/\ue001/g, (m) => quotes[quote++])

                if (!str) return str
                str.replace(/\ue000/g, (match, idx) => {
                    if (idx) parts.push(str.slice(i, idx))
                    i = idx + 1
                    return parts.push(arguments[++field])
                })
                if (i < str.length) parts.push(str.slice(i))
                return parts.length > 1 ? parts : parts[0]
            }

            // close level
            const up = () => {
                // console.log('-level', current);
                ;[current, last, ...args] = current
                current.push(h(last, ...args))
                if (pre === level--) pre = false // reset <pre>
            }

            let str = statics
                .join(FIELD)
                .replace(/<!--[^]*?-->/g, "")
                .replace(/<!\[CDATA\[[^]*\]\]>/g, "")
                .replace(/('|")[^\1]*?\1/g, (match) => (quotes.push(match), QUOTES))

            // ...>text<... sequence
            str.replace(/(?:^|>)((?:[^<]|<[^\w\ue000\/?!>])*)(?:$|<)/g, (match, text, idx, str) => {
                let tag, close

                if (idx) {
                    str.slice(prev, idx)
                        // <abc/> ‚Üí <abc />
                        .replace(/(\S)\/$/, "$1 /")
                        .split(/\s+/)
                        .map((part, i) => {
                            // </tag>, </> .../>
                            if (part[0] === "/") {
                                part = part.slice(1)
                                // ignore duplicate empty closers </input>
                                if (EMPTY[part]) return
                                // ignore pairing self-closing tags
                                close = tag || part || 1
                                // skip </input>
                            }
                            // <tag
                            else if (!i) {
                                tag = evaluate(part)
                                // <p>abc<p>def, <tr><td>x<tr>
                                if (typeof tag === "string") {
                                    while (CLOSE[current[1] + tag]) up()
                                }
                                current = [current, tag, null]
                                level++
                                if (!pre && PRE[tag]) pre = level
                                // console.log('+level', tag)
                                if (EMPTY[tag]) close = tag
                            }
                            // attr=...
                            else if (part) {
                                let props = current[2] || (current[2] = {})
                                if (part.slice(0, 3) === "...") {
                                    Object.assign(props, arguments[++field])
                                } else {
                                    ;[name, value] = part.split("=")
                                    Array.isArray((value = props[evaluate(name)] = value ? evaluate(value) : true)) &&
                                        // if prop value is array - make sure it serializes as string without csv
                                        (value.toString = value.join.bind(value, ""))
                                }
                            }
                        })
                }

                if (close) {
                    if (!current[0]) err(`Wrong close tag \`${close}\``)
                    up()
                    // if last child is optionally closable - close it too
                    while (last !== close && CLOSE[last]) up()
                }
                prev = idx + match.length

                // fix text indentation
                if (!pre) text = text.replace(/\s*\n\s*/g, "").replace(/\s+/g, " ")

                if (text) evaluate(((last = 0), text), current, true)
            })

            if (current[0] && CLOSE[current[1]]) up()

            if (level) err(`Unclosed \`${current[1]}\`.`)

            return current.length < 3 ? current[1] : (current.shift(), current)
        }

        const err = (msg) => {
            throw SyntaxError(msg)
        }

        // self-closing elements
        const EMPTY = (htm.empty = {})

        // optional closing elements
        const CLOSE = (htm.close = {})

        // preformatted text elements
        const PRE = (htm.pre = {})

        // https://github.com/wooorm/html-void-elements/blob/main/index.js
        "area base basefont bgsound br col command embed frame hr image img input keygen link meta param source track wbr ! !doctype ? ?xml".split(" ").map((v) => (htm.empty[v] = true))

        // https://html.spec.whatwg.org/multipage/syntax.html#optional-tags
        // closed by the corresponding tag or end of parent content
        let close = {
            li: "",
            dt: "dd",
            dd: "dt",
            p: "address article aside blockquote details div dl fieldset figcaption figure footer form h1 h2 h3 h4 h5 h6 header hgroup hr main menu nav ol pre section table",
            rt: "rp",
            rp: "rt",
            optgroup: "",
            option: "optgroup",
            caption: "tbody thead tfoot tr colgroup",
            colgroup: "thead tbody tfoot tr caption",
            thead: "tbody tfoot caption",
            tbody: "tfoot caption",
            tfoot: "caption",
            tr: "tbody tfoot",
            td: "th tr",
            th: "td tr tbody",
        }
        for (let tag in close) {
            for (let closer of [...close[tag].split(" "), tag]) htm.close[tag] = htm.close[tag + closer] = true
        }

        "pre textarea".split(" ").map((v) => (htm.pre[v] = true))
        const xhtm = htm

    // 
    // actual elemental
    // 
    const validStyleAttribute = Object.freeze(new Set(["accent-color","align-content","align-items","align-self","align-tracks","all","animation","animation-delay","animation-direction","animation-duration","animation-fill-mode","animation-iteration-count","animation-name","animation-play-state","animation-timeline","animation-timing-function","appearance","ascent-override","aspect-ratio","backdrop-filter","backface-visibility","background","background-attachment","background-blend-mode","background-clip","background-color","background-image","background-origin","background-position","background-position-x","background-position-y","background-repeat","background-size","bleed","block-overflow","block-size","border","border-block","border-block-color","border-block-end","border-block-end-color","border-block-end-style","border-block-end-width","border-block-start","border-block-start-color","border-block-start-style","border-block-start-width","border-block-style","border-block-width","border-bottom","border-bottom-color","border-bottom-left-radius","border-bottom-right-radius","border-bottom-style","border-bottom-width","border-collapse","border-color","border-end-end-radius","border-end-start-radius","border-image","border-image-outset","border-image-repeat","border-image-slice","border-image-source","border-image-width","border-inline","border-inline-color","border-inline-end","border-inline-end-color","border-inline-end-style","border-inline-end-width","border-inline-start","border-inline-start-color","border-inline-start-style","border-inline-start-width","border-inline-style","border-inline-width","border-left","border-left-color","border-left-style","border-left-width","border-radius","border-right","border-right-color","border-right-style","border-right-width","border-spacing","border-start-end-radius","border-start-start-radius","border-style","border-top","border-top-color","border-top-left-radius","border-top-right-radius","border-top-style","border-top-width","border-width","bottom","box-decoration-break","box-shadow","box-sizing","break-after","break-before","break-inside","caption-side","caret-color","clear","clip","clip-path","color","color-scheme","column-count","column-fill","column-gap","column-rule","column-rule-color","column-rule-style","column-rule-width","column-span","column-width","columns","contain","content","content-visibility","counter-increment","counter-reset","counter-set","cursor","length","angle","descent-override","direction","display","resolution","empty-cells","fallback","filter","flex","flex-basis","flex-direction","flex-flow","flex-grow","flex-shrink","flex-wrap","flex_value","float","font","font-display","font-family","font-feature-settings","font-kerning","font-language-override","font-optical-sizing","font-size","font-size-adjust","font-stretch","font-style","font-synthesis","font-variant","font-variant-alternates","font-variant-caps","font-variant-east-asian","font-variant-ligatures","font-variant-numeric","font-variant-position","font-variation-settings","font-weight","forced-color-adjust","gap","grid","grid-area","grid-auto-columns","grid-auto-flow","grid-auto-rows","grid-column","grid-column-end","grid-column-start","grid-row","grid-row-end","grid-row-start","grid-template","grid-template-areas","grid-template-columns","grid-template-rows","frequency","hanging-punctuation","height","hyphenate-character","hyphens","image-orientation","image-rendering","image-resolution","inherit","inherits","initial","initial-letter","initial-letter-align","initial-value","inline-size","input-security","inset","inset-block","inset-block-end","inset-block-start","inset-inline","inset-inline-end","inset-inline-start","isolation","justify-content","justify-items","justify-self","justify-tracks","left","letter-spacing","line-break","line-clamp","line-gap-override","line-height","line-height-step","list-style","list-style-image","list-style-position","list-style-type","margin","margin-block","margin-block-end","margin-block-start","margin-bottom","margin-inline","margin-inline-end","margin-inline-start","margin-left","margin-right","margin-top","margin-trim","marks","mask","mask-border","mask-border-mode","mask-border-outset","mask-border-repeat","mask-border-slice","mask-border-source","mask-border-width","mask-clip","mask-composite","mask-image","mask-mode","mask-origin","mask-position","mask-repeat","mask-size","mask-type","masonry-auto-flow","math-style","max-block-size","max-height","max-inline-size","max-lines","max-width","max-zoom","min-block-size","min-height","min-inline-size","min-width","min-zoom","mix-blend-mode","time","negative","object-fit","object-position","offset","offset-anchor","offset-distance","offset-path","offset-position","offset-rotate","opacity","order","orientation","orphans","outline","outline-color","outline-offset","outline-style","outline-width","overflow","overflow-anchor","overflow-block","overflow-clip-margin","overflow-inline","overflow-wrap","overflow-x","overflow-y","overscroll-behavior","overscroll-behavior-block","overscroll-behavior-inline","overscroll-behavior-x","overscroll-behavior-y","Pseudo-classes","Pseudo-elements","pad","padding","padding-block","padding-block-end","padding-block-start","padding-bottom","padding-inline","padding-inline-end","padding-inline-start","padding-left","padding-right","padding-top","page-break-after","page-break-before","page-break-inside","paint-order","perspective","perspective-origin","place-content","place-items","place-self","pointer-events","position","prefix","print-color-adjust","quotes","range","resize","revert","right","rotate","row-gap","ruby-align","ruby-merge","ruby-position","scale","scroll-behavior","scroll-margin","scroll-margin-block","scroll-margin-block-end","scroll-margin-block-start","scroll-margin-bottom","scroll-margin-inline","scroll-margin-inline-end","scroll-margin-inline-start","scroll-margin-left","scroll-margin-right","scroll-margin-top","scroll-padding","scroll-padding-block","scroll-padding-block-end","scroll-padding-block-start","scroll-padding-bottom","scroll-padding-inline","scroll-padding-inline-end","scroll-padding-inline-start","scroll-padding-left","scroll-padding-right","scroll-padding-top","scroll-snap-align","scroll-snap-stop","scroll-snap-type","scrollbar-color","scrollbar-gutter","scrollbar-width","shape-image-threshold","shape-margin","shape-outside","size","size-adjust","speak-as","src","suffix","symbols","syntax","system","tab-size","table-layout","text-align","text-align-last","text-combine-upright","text-decoration","text-decoration-color","text-decoration-line","text-decoration-skip","text-decoration-skip-ink","text-decoration-style","text-decoration-thickness","text-emphasis","text-emphasis-color","text-emphasis-position","text-emphasis-style","text-indent","text-justify","text-orientation","text-overflow","text-rendering","text-shadow","text-size-adjust","text-transform","text-underline-offset","text-underline-position","top","touch-action","transform","transform-box","transform-origin","transform-style","transition","transition-delay","transition-duration","transition-property","transition-timing-function","translate","unicode-bidi","unicode-range","unset","user-select","user-zoom","vertical-align","viewport-fit","visibility","white-space","widows","width","will-change","word-break","word-spacing","word-wrap","writing-mode","z-index","zoom"]))
    const validNonCallbackHtmlAttributes = Object.freeze(new Set([ "class", "style", "value", "id", "contenteditable", "href", "hidden", "autofocus", "src", "name", "accept", "accesskey", "action", "align", "alt", "async", "autocomplete", "autoplay", "border", "charset", "checked", "cite", "cols", "colspan", "content", "controls", "coords", "data", "datetime", "default", "defer", "dir", "dirname", "disabled", "download", "draggable", "enctype", "for", "form", "formaction", "headers", "high", "hreflang", "http", "ismap", "kind", "label", "lang", "list", "loop", "low", "max", "maxlength", "media", "method", "min", "multiple", "muted", "novalidate", "open", "optimum", "pattern", "placeholder", "poster", "preload", "readonly", "rel", "required", "reversed", "rows", "rowspan", "sandbox", "scope", "selected", "shape", "size", "sizes", "span", "spellcheck", "srcdoc", "srclang", "srcset", "start", "step", "tabindex", "target", "title", "translate", "type", "usemap", "wrap", "bgcolor", "width", "color", "height", ]))
    const isValidStyleAttribute = (key)=>key.startsWith('-')||validStyleAttribute.has(key)
    const kebabCase = (string)=>string.replace(/[a-z]([A-Z])(?=[a-z])/g, (each)=>`${each[0]}-${each.slice(1).toLowerCase()}`)
    const isConstructor = (obj)=>!!obj.prototype && !!obj.prototype.constructor.name
    const attachProperties = (source, target)=> {
        // attach all the static attributes
        const attributes = allKeyDescriptions(source)
        const propertiesDefition = {}
        for (const [key, value] of Object.entries(attributes)) {
            // skip the special keys
            if (['constructor', 'prototype','length',].includes(key)) {
                continue
            }
            propertiesDefition[key] = {
                get: ()=>source[key],
            }
        }
        Object.defineProperties(target, propertiesDefition)
        return target
    }

    export const toHtmlElement = Symbol.for("toHtmlElement")
    class ElementalClass {
        constructor(components={}, options={}) {
            const {middleware, errorComponentFactory, defaultPlaceholderFactory} = options||{}
            this.components = components||{}
            this.middleware = middleware||{}
            this.defaultPlaceholderFactory = defaultPlaceholderFactory||(()=>document.createElement("div"))
            this.errorComponentFactory = errorComponentFactory||defaultErrorComponentFactory
            this.html = this.createElement.bind(this) // alias
            this.xhtm = xhtm.bind((...args)=>this.createElement(...args)) // bind is "when xhtm is done parsing, how should the element be handed" callback
        }

        static debug = false
        static allTags = Symbol.for("allTags")
        static exclusivelySvgElements = new Set(["svg", "animate", "animateMotion", "animateTransform", "circle", "clipPath", "defs", "desc", "discard", "ellipse", "feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence", "filter", "foreignObject", "g", "hatch", "hatchpath", "image", "line", "linearGradient", "marker", "mask", "mesh", "meshgradient", "meshpatch", "meshrow", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "set", "stop", "switch", "symbol", "text", "textPath", "tspan", "unknown", "use", "view",])
        static randomId = (name)=>`${name}${Math.random()}`.replace(".","")
        static makeHtmlElement = function(element) {
            if (element instanceof Node || element instanceof Element || element instanceof HTMLDocument) {
                return element
            // coerce when possible
            } else {
                if (element == null) {
                    return new window.Text("")
                } else if (typeof element == 'string') {
                    return new window.Text(element)
                } else if (typeof element == 'symbol') {
                    // symbols throw errors for: `${symbol}`
                    return new window.Text(element.toString())
                } else if (!(element instanceof Object)) {
                    return new window.Text(`${element}`)
                } else if (element[toHtmlElement] != null) {
                    return ElementalClass.makeHtmlElement(element[toHtmlElement])
                } else {
                    throw Error(`Cannot coerce ${element} into an html element`)
                }
            }
        }
        static appendChildren = function(element, ...children) {
            const { element: altElement, insertBefore } = element
            let primitiveAppend = (child)=>element.appendChild(child)
            if (insertBefore && !(insertBefore instanceof Function)) {
                element = altElement
                primitiveAppend = (child)=>element.insertBefore(insertBefore, child)
            }
            for (const each of children) {
                if (each instanceof Array) {
                    // effectively flattens nested arrays
                    ElementalClass.appendChildren(element, ...each)
                } else if (each instanceof Function) {
                    // recursively
                    ElementalClass.appendChildren(element, each())
                } else if (each instanceof Promise) {
                    const elementPromise = each
                    const placeholder = elementPromise.placeholder || document.createElement("div") // TODO: appendChildren needs to NOT be a static function so that this can use this.defaultPlaceholderFactory()
                    primitiveAppend(placeholder)
                    setTimeout(async () => {
                        try {
                            const result = await elementPromise
                            if (!(result instanceof Array)) {
                                const htmlElement = ElementalClass.makeHtmlElement(result)
                                placeholder.replaceWith(htmlElement)
                            // if array output
                            } else {
                                // TODO: needs a cleaner solution, but it will require a major refactor 
                                let parentElement = placeholder.parentElement
                                if (!parentElement) {
                                    parentElement = await new Promise((resolve, reject)=>{
                                        let intervalId = setInterval(() => {
                                            if (placeholder.parentElement) {
                                                resolve(placeholder.parentElement)
                                                clearInterval(intervalId)
                                            }
                                        }, 70)
                                    })
                                }
                                // add all the children
                                for (const each of result) {
                                    try {
                                        // recursive so that nested arrays of promises still work
                                        ElementalClass.appendChildren({
                                            element: parentElement,
                                            insertBefore: placeholder,
                                        }, each)
                                    } catch (error) {
                                        parentElement.insertBefore(placeholder, createErrorElement(`When async component ${toString(element)} resolved, it created an array. One of those elements in the array caused an error when it tried to be added as a child:\n ${toString(error)}`))
                                    }
                                }
                            }
                        } catch (error) {
                            placeholder.replaceWith(
                                defaultErrorComponentFactory({...properties, children}, key, error)
                            )
                        }
                    }, 0)
                } else {
                    primitiveAppend(ElementalClass.makeHtmlElement(each))
                }
            }
            return element
        }
        static css = function(first, ...args) {
            if (typeof first == 'string') {
                return first
            } else if (first == null) {
                return ""
            // templated string
            } else if (first instanceof Array) {
                const strings = first
                const values = args
                let finalString = ""
                for (const each of strings) {
                    finalString += each
                    if (values.length > 0) {
                        const value = values.shift()
                        if (value instanceof Object) {
                            // recursion but always a depth of only +1 from this point
                            finalString += Elemental.css(value)
                        } else {
                            finalString += `${value}`
                        }
                    }
                }
                return finalString
            } else if (first instanceof Object) {
                let finalString = ""
                for (const [key, value] of Object.entries(first)) {
                    if (value != null) {
                        finalString += `${kebabCase(key)}: ${value};`
                    }
                }
                return finalString
            } else {
                return first
            }
        }
        static combineClasses = (...classes) => {
            classes = classes.filter(each=>each!=null)
            let classesFinalList = []
            for (let eachEntry of classes) {
                // handle strings
                if (typeof eachEntry == 'string') {
                    eachEntry = eachEntry.split(" ")
                }
                // handle lists
                if (eachEntry instanceof Array) {
                    eachEntry = eachEntry.flat(Infinity)
                    for (let eachName of eachEntry) {
                        classesFinalList.push(eachName)
                    }
                // handle objects
                } else if (eachEntry instanceof Object) {
                    for (const [className, enabled] of Object.entries(eachEntry)) {
                        if (enabled) {
                            classesFinalList.push(className)
                        }
                    }
                }
            }
            return classesFinalList
        }

        createElement(...args) {
            // template call
            if (args[0] instanceof Array) {
                const output = this.xhtm(...args)
                return output
            // jsx call
            } else {
                ElementalClass.debug && console.debug(`args is:`,args)

                // run middleware
                for (const middleware of (this.middleware[ElementalClass.allTags]||[]).concat((this.middleware[args[0]]||[]))) {
                    try {
                        args = eachMiddleWare(args)
                    } catch (error) {
                        console.error("[ElementalClass] one of the middleware functions failed:", eachMiddleWare, args)
                    }
                    // TODO: handle middleware creating invalid arguments
                }
                
                let [ key, properties, ...children ] = args
                ElementalClass.debug && console.debug(`key, properties, children is:`,key, properties, children)
                // lookup custom components
                if (this.components[key] instanceof Function) {
                    key = this.components[key]
                }
                // run custom components
                if (key instanceof Function) {
                    let output
                    try {
                        output = isConstructor(key) ? new key({...properties, children}) : key({...properties, children})
                    } catch (error) {
                        return this.errorComponentFactory({...properties, children}, key, error)
                    }
                    // allow async components
                    if (output instanceof Promise) {
                        const elementPromise = output
                        const placeholder = elementPromise.placeholder || this.defaultPlaceholderFactory(output)
                        setTimeout(async () =>{
                            try {
                                const result = await elementPromise
                                if (!(result instanceof Array)) {
                                    const htmlElement = ElementalClass.makeHtmlElement(result)
                                    placeholder.replaceWith(htmlElement)
                                // if array output
                                } else {
                                    // TODO: needs a cleaner solution, but it will require a major refactor
                                    let parentElement = placeholder.parentElement
                                    if (!parentElement) {
                                        parentElement = await new Promise((resolve, reject)=>{
                                            let intervalId = setInterval(() => {
                                                if (placeholder.parentElement) {
                                                    resolve(placeholder.parentElement)
                                                    clearInterval(intervalId)
                                                }
                                            }, 70)
                                        })
                                    }
                                    // add all the children
                                    for (const each of result) {
                                        try {
                                            // recursive so that nested arrays of promises still work
                                            ElementalClass.appendChildren({
                                                element: parentElement,
                                                insertBefore: placeholder,
                                            }, each)
                                        } catch (error) {
                                            parentElement.insertBefore(placeholder, createErrorElement(`Something returned a promise, which resolved to an array, and then something tried to append those to an element (this element: ${element}). One of the items in the array ${each} caused an error when it tried to be added as a child:\n ${toString(error)}`))
                                        }
                                    }
                                }
                            } catch (error) {
                                placeholder.replaceWith(
                                    this.errorComponentFactory({...properties, children}, key, error)
                                )
                            }
                        }, 0)
                        return placeholder
                    } else {
                        return output
                    }
                }
                // create either an html element or an svg element
                const isSvg = ElementalClass.exclusivelySvgElements.has(key)
                const element = isSvg ? document.createElementNS('http://www.w3.org/2000/svg', key) : document.createElement(key)
                let styleString = ""
                if (properties instanceof Object) {
                    for (let [key, value] of Object.entries(properties)) {
                        // 
                        // styles
                        // 
                        if (key == 'style') {
                            // styles are done at the end in a batch
                            styleString +=  ElementalClass.css(value)
                            continue
                        }

                        // 
                        // events
                        // 
                        if (key.slice(0,2) == 'on' && (key.slice(2,3).toLowerCase() !== key.slice(2,3)) && value instanceof Function) {
                            element.addEventListener(key.slice(2).toLowerCase(), value)
                        }

                        // 
                        // css classes
                        // 
                        if (key ==  'class') {
                            if (value instanceof Array) {
                                value = value.join(" ")
                            } else if (value instanceof Object) {
                                let newValue = ""
                                for (const [classString, enable] of Object.entries(value)) {
                                    if (enable) {
                                        newValue += classString
                                    }
                                }
                                value = newValue
                            }
                        }
                        
                        // 
                        // svgs
                        // 
                        if (isSvg) {
                            if (value instanceof Array) {
                                value = value.join(" ")
                            }
                            element.setAttribute(kebabCase(key), value)
                            continue
                        }
                        
                        // 
                        // direct html attributes
                        // 
                        if (value != null && !(value instanceof Object) && validNonCallbackHtmlAttributes.has(key)) {
                            element.setAttribute(key, value)
                        }

                        // 
                        // the object property
                        // 
                        try {
                            element[key] = value
                        } catch (error) {
                            
                        }

                        // 
                        // lazy styles
                        // 
                        if (isValidStyleAttribute(key)) {
                            styleString += `;${key}: ${value};`
                        }
                    }
                }

                if (styleString) {
                    // set all styles at once
                    element.setAttribute("style", styleString)
                }
                return ElementalClass.appendChildren(element, ...children)
            }
        }

        extend(additionalComponents={}, options={}) {
            const {middleware, ...other} = options||{}
            return Elemental(
                {...this.components, ...additionalComponents},
                {
                    middleware:{...this.middleware, ...middleware},
                    ...other
                }
            )
        }
    }

    // 
    // a wrapper so that ElementalClass can pretend to be a function
    //    e.g. Elemental() returns a function, but that function behaves like an instance of new ElementalClass()
    // 
    export const Elemental = (...args) => {
        const elementalObject = new ElementalClass(...args)
        const createElementFunction = elementalObject.createElement.bind(elementalObject)
        // attach static and normal attributes
        attachProperties(ElementalClass, createElementFunction)
        attachProperties(elementalObject, createElementFunction)
        return createElementFunction
    }
    attachProperties(ElementalClass, Elemental)

    function createErrorElement(error) {
        const element = document.createElement("div")
        element.setAttribute('style', `
            all:              unset;
            display:          flex;
            flex-direction:   column;
            padding:          1.5rem;
            background-color: #f5a5a8;
            color:            white;
            font-family:      -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen-Sans,Ubuntu,Cantarell,"Helvetica Neue",sans-serif;
            font-size:        18px;
            font-weight:      400;
            overflow:         auto;
        `)
        element.innerHTML = `I'm sorry, there was an error when loading this part of the page üôÅ.<br>Here's the error message: ${ Option(toString(error!=null&&error.message||error)).innerHTML}`

    }
    function defaultErrorComponentFactory({children, ...properties}, key, error) {
        const element = document.createElement("div")
        const errorDetails = document.createElement("code")
        const childContainer = document.createElement("div")
        
        // 
        // error body
        // 
        element.setAttribute('style', `
            all:              unset;
            display:          flex;
            flex-direction:   column;
            padding:          1.5rem;
            background-color: #f5a5a8;
            color:            white;
            font-family:      -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen-Sans,Ubuntu,Cantarell,"Helvetica Neue",sans-serif;
            font-size:        18px;
            font-weight:      400;
            overflow:         auto;
        `)
        element.innerHTML = `I'm sorry, there was an error when loading this part of the page üôÅ `
        
        // 
        // error details
        // 
        let errorElementPart
        if (typeof key == 'string') {
            errorElementPart = `<${key} />`
        } else {
            try {
                // classes
                errorElementPart = `<${key.prototype.constructor.name} />`
            } catch (error) {
                try {
                    // functions
                    errorElementPart = `<${key.name} />`
                } catch (error) {
                    // unknown
                    errorElementPart = `<${key} />`
                }
            }
        }
        let errorJsonObject = {}
        for (const [key, value] of Object.entries(properties)) {
            try {
                errorJsonObject[key] = JSON.parse(JSON.stringify(value))
            } catch (error) {
                errorJsonObject[key] = `${value}`
            }
        }
        errorDetails.innerHTML = `tag: ${errorElementPart}\nproperties: ${JSON.stringify(errorJsonObject,0,4)}\nerror: ${error}`
        errorDetails.setAttribute('style', `
            padding: 1rem;
            background-color: #161b22;
            color: #789896;
            white-space: pre;
            max-width: 85vw;
            overflow: auto;
        `)
        element.appendChild(errorDetails)
        // 
        // children
        // 
        childContainer.setAttribute('style', `
            all: unset
            display: flex
            flex-direction: column
            margin-top: 1.3rem
        `)
        ElementalClass.appendChildren(childContainer, children)
        element.appendChild(childContainer)
        return element
    }

    // 
    // protect document head by monkey patching it (this is the only monkeypatch)
    // 
    try {
        const originalHead = document.head
        Object.defineProperty(document,"head", { 
            set: (element) => ElementalClass.appendChildren(originalHead, ...element.childNodes),
            get: ()=>originalHead,
            writable: true,
        })
    } catch (error) {
        
    }
    window.Elemental = Elemental
</script>
<!--          -->
<!-- Toastify -->
<!--          -->
<script type="module">
    // 
    // Toast
    // 
        import { css, cx } from 'https://cdn.skypack.dev/-/@emotion/css@v11.10.5-uWGULTiBZCR27o2j9H2P/dist=es2019,mode=imports/optimized/@emotion/css.js'
    
        const toastOn = css``
        const toastify = css`
            padding: 12px 20px;
            color: #ffffff;
            display: inline-block;
            box-shadow: 0 3px 6px -1px rgba(0, 0, 0, 0.12), 0 10px 36px -4px rgba(77, 96, 232, 0.3);
            background: -webkit-linear-gradient(315deg, #73a5ff, #5477f5);
            background: linear-gradient(135deg, #73a5ff, #5477f5);
            position: fixed;
            opacity: 0;
            transition: all 0.4s cubic-bezier(0.215, 0.61, 0.355, 1);
            border-radius: 2px;
            cursor: pointer;
            text-decoration: none;
            max-width: calc(50% - 20px);
            z-index: 2147483647;
            &${toastOn} {
                opacity: 1;
            }
        `


        const toastClose = css`
            background: transparent;
            border: 0;
            color: white;
            cursor: pointer;
            font-family: inherit;
            font-size: 1em;
            opacity: 0.4;
            padding: 0 5px;
        `

        const toastifyRight = css`
            right: 15px;
            @media only screen and (max-width: 360px) {
                margin-left: auto;
                margin-right: auto;
                left: 0;
                right: 0;
                max-width: fit-content;
            }
        `

        const toastifyLeft = css`
            left: 15px;
            @media only screen and (max-width: 360px) {
                margin-left: auto;
                margin-right: auto;
                left: 0;
                right: 0;
                max-width: fit-content;
            }
        `

        const toastifyTop = css`
            top: 50px;
        `

        const toastifyBottom = css`
            bottom: 50px;
        `

        const toastifyRounded = css`
            border-radius: 25px;
        `

        const toastifyAvatar = css`
            width: 1.5em;
            height: 1.5em;
            margin: -7px 5px;
            border-radius: 2px;
        `

        const toastifyCenter = css`
            margin-left: auto;
            margin-right: auto;
            left: 0;
            right: 0;
            max-width: fit-content;
            max-width: -moz-fit-content;
        `

        const nameMapping = {
            right: toastifyRight,
            left: toastifyLeft,
            top: toastifyTop,
            bottom: toastifyBottom,
            rounded: toastifyRounded,
            avatar: toastifyAvatar,
            center: toastifyCenter,
        }

        /*!
        * Toastify js 1.12.0
        * https://github.com/apvarun/toastify-js
        * @license MIT licensed
        *
        * Copyright (C) 2018 Varun A P
        */

        /**
        * Options used for Toastify
        * @typedef {Object} ToastifyConfigurationObject
        * @property {string} text - Message to be displayed in the toast
        * @property {Element} node - Provide a node to be mounted inside the toast. node takes higher precedence over text
        * @property {number} duration - Duration for which the toast should be displayed. -1 for permanent toast
        * @property {string|Element} selector - CSS ID Selector on which the toast should be added
        * @property {url} destination - URL to which the browser should be navigated on click of the toast
        * @property {boolean} newWindow - Decides whether the destination should be opened in a new window or not
        * @property {boolean} close - To show the close icon or not
        * @property {string} gravity - To show the toast from top or bottom
        * @property {string} position - To show the toast on left or right
        * @property {string} backgroundColor - Deprecated: Sets the background color of the toast
        * @property {url} avatar - Image/icon to be shown before text
        * @property {string} className - Ability to provide custom class name for further customization
        * @property {boolean} stopOnFocus - To stop timer when hovered over the toast (Only if duration is set)
        * @property {Function} callback - Invoked when the toast is dismissed
        * @property {Function} onClick - Invoked when the toast is clicked
        * @property {Object} offset - Ability to add some offset to axis
        * @property {boolean} escapeMarkup - Toggle the default behavior of escaping HTML markup
        * @property {string} ariaLive - Use the HTML DOM style property to add styles to toast
        * @property {Object} style - Use the HTML DOM style property to add styles to toast
        */

        class Toastify {
            defaults = {
                oldestFirst: true,
                text: "Toastify is awesome!",
                node: undefined,
                duration: 3000,
                selector: undefined,
                callback: function () {},
                destination: undefined,
                newWindow: false,
                close: false,
                gravity: toastifyBottom,
                positionLeft: false,
                position: "",
                backgroundColor: "",
                avatar: "",
                className: "",
                stopOnFocus: true,
                onClick: function () {},
                offset: { x: 0, y: 0 },
                escapeMarkup: true,
                ariaLive: "polite",
                style: { background: "" },
            }
            
            /**
            * Init the Toastify class
            * @example
            *     new Toastify({
            *         text: "This is a toast",
            *         duration: 3000
            *     }).showToast()
            *
            * @param {ToastifyConfigurationObject} options - The configuration object to configure Toastify
            * @param {string} [options.text=Hi there!] - Message to be displayed in the toast
            * @param {Element} [options.node] - Provide a node to be mounted inside the toast. node takes higher precedence over text
            * @param {number} [options.duration=3000] - Duration for which the toast should be displayed. -1 for permanent toast
            * @param {string} [options.selector] - CSS Selector on which the toast should be added
            * @param {url} [options.destination] - URL to which the browser should be navigated on click of the toast
            * @param {boolean} [options.newWindow=false] - Decides whether the destination should be opened in a new window or not
            * @param {boolean} [options.close=false] - To show the close icon or not
            * @param {string} [options.gravity=toastify-top] - To show the toast from top or bottom
            * @param {string} [options.position=right] - To show the toast on left or right
            * @param {string} [options.backgroundColor] - Sets the background color of the toast (To be deprecated)
            * @param {url} [options.avatar] - Image/icon to be shown before text
            * @param {string} [options.className] - Ability to provide custom class name for further customization
            * @param {boolean} [options.stopOnFocus] - To stop timer when hovered over the toast (Only if duration is set)
            * @param {Function} [options.callback] - Invoked when the toast is dismissed
            * @param {Function} [options.onClick] - Invoked when the toast is clicked
            * @param {Object} [options.offset] - Ability to add some offset to axis
            * @param {boolean} [options.escapeMarkup=true] - Toggle the default behavior of escaping HTML markup
            * @param {string} [options.ariaLive] - Announce the toast to screen readers
            * @param {Object} [options.style] - Use the HTML DOM style property to add styles to toast
            */
            constructor(options) {
                /**
                * The version of Toastify
                * @type {string}
                * @public
                */
                this.version = "1.12.0"

                /**
                * The configuration object to configure Toastify
                * @type {ToastifyConfigurationObject}
                * @public
                */
                this.options = {}

                /**
                * The element that is the Toast
                * @type {Element}
                * @public
                */
                this.toastElement = null

                /**
                * The root element that contains all the toasts
                * @type {Element}
                * @private
                */
                this._rootElement = document.body

                // Setting defaults
                this.options = Object.assign(this.defaults, options)

                if (this.options.backgroundColor) {
                    // This is being deprecated in favor of using the style HTML DOM property
                    console.warn('DEPRECATION NOTICE: "backgroundColor" is being deprecated. Please use the "style.background" property.')
                }

                this.toastElement = null

                this.options.gravity = options.gravity === "bottom" ? toastifyBottom : toastifyTop // toast position - top or bottom
                this.options.stopOnFocus = options.stopOnFocus === undefined ? true : options.stopOnFocus // stop timeout on focus
                if (options.backgroundColor) {
                    this.options.style.background = options.backgroundColor
                }
            }

            /**
            * Display the toast
            * @public
            */
            showToast() {
                // Creating the DOM object for the toast
                this.toastElement = this._buildToast()

                // Getting the root element to with the toast needs to be added
                if (typeof this.options.selector === "string") {
                    this._rootElement = document.getElementById(this.options.selector)
                } else if (this.options.selector instanceof HTMLElement || this.options.selector instanceof ShadowRoot) {
                    this._rootElement = this.options.selector
                } else {
                    this._rootElement = document.body
                }

                // Validating if root element is present in DOM
                if (!this._rootElement) {
                    throw "Root element is not defined"
                }

                // Adding the DOM element
                this._rootElement.insertBefore(this.toastElement, this._rootElement.firstChild)

                // Repositioning the toasts in case multiple toasts are present
                this._reposition()

                if (this.options.duration > 0) {
                    this.toastElement.timeOutValue = window.setTimeout(() => {
                        // Remove the toast from DOM
                        this._removeElement(this.toastElement)
                    }, this.options.duration) // Binding `this` for function invocation
                }

                // Supporting function chaining
                return this
            }

            /**
            * Hide the toast
            * @public
            */
            hideToast() {
                if (this.toastElement.timeOutValue) {
                    clearTimeout(this.toastElement.timeOutValue)
                }
                this._removeElement(this.toastElement)
            }

            /**
            * Build the Toastify element
            * @returns {Element}
            * @private
            */
            _buildToast() {
                // Validating if the options are defined
                if (!this.options) {
                    throw "Toastify is not initialized"
                }

                // Creating the DOM object
                let divElement = document.createElement("div")
                divElement.className = `${toastify} ${toastOn} ${this.options.className}`

                // Positioning toast to left or right or center (default right)
                divElement.className += ` ${nameMapping[this.options.position]}`

                // Assigning gravity of element
                divElement.className += ` ${this.options.gravity}`

                // Loop through our style object and apply styles to divElement
                for (const property in this.options.style) {
                    divElement.style[property] = this.options.style[property]
                }

                // Announce the toast to screen readers
                if (this.options.ariaLive) {
                    divElement.setAttribute("aria-live", this.options.ariaLive)
                }

                // Adding the toast message/node
                if (this.options.node && this.options.node.nodeType === Node.ELEMENT_NODE) {
                    // If we have a valid node, we insert it
                    divElement.appendChild(this.options.node)
                } else {
                    if (this.options.escapeMarkup) {
                        divElement.innerText = this.options.text
                    } else {
                        divElement.innerHTML = this.options.text
                    }

                    if (this.options.avatar !== "") {
                        let avatarElement = document.createElement("img")
                        avatarElement.src = this.options.avatar

                        avatarElement.className = toastifyAvatar

                        if (this.options.position == "left") {
                            // Adding close icon on the left of content
                            divElement.appendChild(avatarElement)
                        } else {
                            // Adding close icon on the right of content
                            divElement.insertAdjacentElement("afterbegin", avatarElement)
                        }
                    }
                }

                // Adding a close icon to the toast
                if (this.options.close === true) {
                    // Create a span for close element
                    let closeElement = document.createElement("button")
                    closeElement.type = "button"
                    closeElement.setAttribute("aria-label", "Close")
                    closeElement.className = toastClose
                    closeElement.innerHTML = "&#10006;"

                    // Triggering the removal of toast from DOM on close click
                    closeElement.addEventListener("click", (event) => {
                        event.stopPropagation()
                        this._removeElement(this.toastElement)
                        window.clearTimeout(this.toastElement.timeOutValue)
                    })

                    //Calculating screen width
                    const width = window.innerWidth > 0 ? window.innerWidth : screen.width

                    // Adding the close icon to the toast element
                    // Display on the right if screen width is less than or equal to 360px
                    if (this.options.position == "left" && width > 360) {
                        // Adding close icon on the left of content
                        divElement.insertAdjacentElement("afterbegin", closeElement)
                    } else {
                        // Adding close icon on the right of content
                        divElement.appendChild(closeElement)
                    }
                }

                // Clear timeout while toast is focused
                if (this.options.stopOnFocus && this.options.duration > 0) {
                    // stop countdown
                    divElement.addEventListener("mouseover", (event) => {
                        window.clearTimeout(divElement.timeOutValue)
                    })
                    // add back the timeout
                    divElement.addEventListener("mouseleave", () => {
                        divElement.timeOutValue = window.setTimeout(() => {
                            // Remove the toast from DOM
                            this._removeElement(divElement)
                        }, this.options.duration)
                    })
                }

                // Adding an on-click destination path
                if (typeof this.options.destination !== "undefined") {
                    divElement.addEventListener("click", (event) => {
                        event.stopPropagation()
                        if (this.options.newWindow === true) {
                            window.open(this.options.destination, "_blank")
                        } else {
                            window.location = this.options.destination
                        }
                    })
                }

                if (typeof this.options.onClick === "function" && typeof this.options.destination === "undefined") {
                    divElement.addEventListener("click", (event) => {
                        event.stopPropagation()
                        this.options.onClick()
                    })
                }

                // Adding offset
                if (typeof this.options.offset === "object") {
                    const x = this._getAxisOffsetAValue("x", this.options)
                    const y = this._getAxisOffsetAValue("y", this.options)

                    const xOffset = this.options.position == "left" ? x : `-${x}`
                    const yOffset = this.options.gravity == toastifyTop ? y : `-${y}`

                    divElement.style.transform = `translate(${xOffset},${yOffset})`
                }

                // Returning the generated element
                return divElement
            }

            /**
            * Remove the toast from the DOM
            * @param {Element} toastElement
            */
            _removeElement(toastElement) {
                // Hiding the element
                toastElement.className = toastElement.className.replace(` ${toastOn}`, "")

                // Removing the element from DOM after transition end
                window.setTimeout(() => {
                    // remove options node if any
                    if (this.options.node && this.options.node.parentNode) {
                        this.options.node.parentNode.removeChild(this.options.node)
                    }

                    // Remove the element from the DOM, only when the parent node was not removed before.
                    if (toastElement.parentNode) {
                        toastElement.parentNode.removeChild(toastElement)
                    }

                    // Calling the callback function
                    this.options.callback.call(toastElement)

                    // Repositioning the toasts again
                    this._reposition()
                }, 400) // Binding `this` for function invocation
            }

            /**
            * Position the toast on the DOM
            * @private
            */
            _reposition() {
                // Top margins with gravity
                let topLeftOffsetSize = {
                    top: 15,
                    bottom: 15,
                }
                let topRightOffsetSize = {
                    top: 15,
                    bottom: 15,
                }
                let offsetSize = {
                    top: 15,
                    bottom: 15,
                }

                // Get all toast messages that have been added to the container (selector)
                let allToasts = this._rootElement.querySelectorAll(`.${toastify}`)

                let classUsed
                let topOrBottom

                // Modifying the position of each toast element
                for (let i = 0; i < allToasts.length; i++) {
                    // Getting the applied gravity
                    if (allToasts[i].classList.contains(toastifyTop) === true) {
                        classUsed = toastifyTop
                        topOrBottom = "top"
                    } else {
                        classUsed = toastifyBottom
                        topOrBottom = "bottom"
                    }

                    let height = allToasts[i].offsetHeight
                    classUsed = classUsed.substr(9, classUsed.length - 1)
                    // Spacing between toasts
                    let offset = 15

                    let width = window.innerWidth > 0 ? window.innerWidth : screen.width

                    // Show toast in center if screen with less than or equal to 360px
                    if (width <= 360) {
                        // Setting the position
                        allToasts[i].style[topOrBottom] = `${offsetSize[topOrBottom]}px`

                        offsetSize[topOrBottom] += height + offset
                    } else {
                        if (allToasts[i].classList.contains(toastifyLeft) === true) {
                            // Setting the position
                            allToasts[i].style[topOrBottom] = `${topLeftOffsetSize[topOrBottom]}px`

                            topLeftOffsetSize[topOrBottom] += height + offset
                        } else {
                            // Setting the position
                            allToasts[i].style[topOrBottom] = `${topRightOffsetSize[topOrBottom]}px`

                            topRightOffsetSize[topOrBottom] += height + offset
                        }
                    }
                }
            }

            /**
            * Helper function to get offset
            * @param {string} axis - 'x' or 'y'
            * @param {ToastifyConfigurationObject} options - The options object containing the offset object
            */
            _getAxisOffsetAValue(axis, options) {
                if (options.offset[axis]) {
                    if (isNaN(options.offset[axis])) {
                        return options.offset[axis]
                    } else {
                        return `${options.offset[axis]}px`
                    }
                }

                return "0px"
            }
        }
        window.Toastify = Toastify
    // example:
    //     new Toastify({
    //         text: message,
    //         position: 'right',
    //         backgroundColor: "#ef6c00",
    //         gravity: "bottom",
    //         duration: 8000,
    //     }).showToast()
</script>
<!--                -->
<!-- The main code  -->
<!--                -->
<script type="module">//;(async () => {
    // 
    // 
    // Initialize
    // 
    // 
        import * as gridjs from "https://cdn.skypack.dev/gridjs@6.0.6"
        import storageObject from "https://deno.land/x/storage_object@0.0.2.0/main.js"
        // const ElementalLibrary = (await import("https://cdn.skypack.dev/@!!!!!/elemental@0.0.12")).default
        // const ContainerLibrary = (await import("https://cdn.skypack.dev/@!vanilla/container@v1.0.5")).default
        // inlined version of what is above
        const [ ElementalLibrary, ContainerLibrary ] = (()=>{var e = "\uE000", t = "\uE001"; function o(r2) {  var p2, a1, l, s, c = arguments, i = this, n = 0, d = [], h = 0, u = [], f = 0;  d.root = true;  var g = function(e2, o2, r3) {  o2 === void 0 && (o2 = []);  var p3 = 0;  return (e2 = r3 || e2 !== t ? e2.replace(/\ue001/g, (e3)=>u[f++]  ) : u[f++].slice(1, -1)) ? (e2.replace(/\ue000/g, (t2, r4)=>(r4 && o2.push(e2.slice(p3, r4)), p3 = r4 + 1, o2.push(c[++h]))  ), p3 < e2.length && o2.push(e2.slice(p3)), o2.length > 1 ? o2 : o2[0]) : e2;  }, m = ()=>{  [d, s, ...p2] = d, d.push(i(s, ...p2));  };  return r2.join(e).replace(/<!--[^]*-->/g, "").replace(/<!\[CDATA\[[^]*\]\]>/g, "").replace(/('|")[^\1]*?\1/g, (e2)=>(u.push(e2), t)  ).replace(/\s+/g, " ").replace(/(?:^|>)([^<]*)(?:$|<)/g, (e2, t2, r3, p3)=>{  var c2, i2;  if (r3 && p3.slice(n, r3).replace(/(\S)\/$/, "$1 /").split(" ").map((e3, t3)=>{  if (e3[0] === "/") c2 = i2 || e3.slice(1) || 1;  else if (t3) {  if (e3) {  var r4 = d[2] || (d[2] = {});  e3.slice(0, 3) === "..." ? Object.assign(r4, arguments[++h]) : ([a1, l] = e3.split("="), r4[g(a1)] = !l || g(l));  }  } else {  for(i2 = g(e3); o.close[d[1] + i2];)m();  d = [  d,  i2,  null  ], o.empty[i2] && (c2 = i2);  }  }), c2) for(m(); s !== c2 && o.close[s];)m();  n = r3 + e2.length, t2 && t2 !== " " && g((s = 0, t2), d, true);  }), d.root || m(), d.length > 1 ? d : d[0]; } o.empty = {}, o.close = {}, "area base br col command embed hr img input keygen link meta param source track wbr ! !doctype ? ?xml".split(" ").map((e2)=>o.empty[e2] = o.empty[e2.toUpperCase()] = true ); var r = {  li: "",  dt: "dd",  dd: "dt",  p: "address article aside blockquote details div dl fieldset figcaption figure footer form h1 h2 h3 h4 h5 h6 header hgroup hr main menu nav ol pre section table",  rt: "rp",  rp: "rt",  optgroup: "",  option: "optgroup",  caption: "tbody thead tfoot tr colgroup",  colgroup: "thead tbody tfoot tr caption",  thead: "tbody tfoot caption",  tbody: "tfoot caption",  tfoot: "caption",  tr: "tbody tfoot",  td: "th tr",  th: "td tr tbody" }, p = function(e2) {  [  ...r[e2].split(" "),  e2  ].map((t2)=>{  o.close[e2] = o.close[e2.toUpperCase()] = o.close[e2 + t2] = o.close[e2.toUpperCase() + t2] = o.close[e2 + t2.toUpperCase()] = o.close[e2.toUpperCase() + t2.toUpperCase()] = true;  }); }; for(var a in r)p(a); const xhtm = o; class Elemental {  constructor(components = {}, options = {}){  const { middleware: middleware2 , errorComponentFactory } = options;  this.components = components || {};  this.middleware = middleware2 || {};  this.errorComponentFactory = errorComponentFactory || defaultErrorComponentFactory;  this.html = xhtm.bind((...args)=>this.createElement(...args)  );  this.css = Elemental.css;  }  createElement(...args) {  Elemental.debug && console.debug(`args is:`, args);  for (const middleware2 of (this.middleware[Elemental.allTags] || []).concat(this.middleware[args[0]] || [])){  try {  args = eachMiddleWare(args);  } catch (error) {  console.error("[elemental] one of the middleware functions failed:", eachMiddleWare, args);  }  }  let [key, properties, ...children] = args;  Elemental.debug && console.debug(`key, properties, children is:`, key, properties, children);  if (this.components[key] instanceof Function) {  key = this.components[key];  }  if (key instanceof Function) {  let output;  try {  output = isConstructor(key) ? new key({  ...properties,  children  }) : key({  ...properties,  children  });  } catch (error) {  return this.errorComponentFactory({  ...properties,  children  }, key, error);  }  if (output instanceof Promise) {  const elementPromise = output;  const placeholder = elementPromise.placeholder || document.createElement("div");  setTimeout(async ()=>placeholder.replaceWith(await elementPromise)  , 0);  return placeholder;  } else {  return output;  }  }  const isSvg = Elemental.exclusivelySvgElements.has(key);  const element = isSvg ? document.createElementNS("http://www.w3.org/2000/svg", key) : document.createElement(key);  if (properties instanceof Object) {  for (const [key2, value] of Object.entries(properties)){  try {  if (isSvg) {  const kebabCase = key2.replace(/(?<=[a-z])([A-Z])(?=[a-z])/g, (each2)=>`-${each2.toLowerCase()}`  );  element.setAttribute(kebabCase, value);  } else {  element.setAttribute(key2.toLowerCase(), value);  }  } catch (error) {}  try {  element[key2] = value;  } catch (error1) {}  }  }  return appendChildren(element, ...children);  }  extend(additionalComponents = {}, options = {}) {  const { additionalMiddleware , ...other } = options;  return new Elemental({  ...this.components,  ...additionalComponents  }, {  middleware: {  ...this.middleware,  ...middleware  },  ...other  });  } } Elemental.allTags = Symbol.for("allTags"); Elemental.exclusivelySvgElements = new Set([  "svg",  "animate",  "animateMotion",  "animateTransform",  "circle",  "clipPath",  "defs",  "desc",  "discard",  "ellipse",  "feBlend",  "feColorMatrix",  "feComponentTransfer",  "feComposite",  "feConvolveMatrix",  "feDiffuseLighting",  "feDisplacementMap",  "feDistantLight",  "feDropShadow",  "feFlood",  "feFuncA",  "feFuncB",  "feFuncG",  "feFuncR",  "feGaussianBlur",  "feImage",  "feMerge",  "feMergeNode",  "feMorphology",  "feOffset",  "fePointLight",  "feSpecularLighting",  "feSpotLight",  "feTile",  "feTurbulence",  "filter",  "foreignObject",  "g",  "hatch",  "hatchpath",  "image",  "line",  "linearGradient",  "marker",  "mask",  "mesh",  "meshgradient",  "meshpatch",  "meshrow",  "metadata",  "mpath",  "path",  "pattern",  "polygon",  "polyline",  "radialGradient",  "rect",  "set",  "stop",  "switch",  "symbol",  "text",  "textPath",  "tspan",  "unknown",  "use",  "view" ]); Elemental.css = function(...args) {  const element = document.createElement("div");  if (args.length == 1) {  if (args instanceof Object) {  Object.assign(element.style, args);  }  } else if (args.length > 1) {  const [strings, ...values] = args;  let finalString = "";  for (const each2 of strings){  finalString += each2;  if (values.length > 0) {  finalString += `${values.shift()}`;  }  }  element.style = finalString;  }  return element.style; }; function appendChildren(element, ...children) {  for (const each2 of children){  if (typeof each2 == "string") {  element.appendChild(new window.Text(each2));  } else if (each2 == null) {  element.appendChild(new window.Text(""));  } else if (!(each2 instanceof Object)) {  element.appendChild(new window.Text(`${each2}`));  } else if (each2 instanceof Node) {  element.appendChild(each2);  } else if (each2 instanceof Array) {  appendChildren(element, ...each2);  } else if (each2 instanceof Function) {  appendChildren(element, each2());  } else if (each2 instanceof Promise) {  const elementPromise = each2;  const placeholder = elementPromise.placeholder || document.createElement("div");  setTimeout(async ()=>placeholder.replaceWith(await elementPromise)  , 0);  element.appendChild(placeholder);  } else if (each2 != null && each2 instanceof Object) {  element.appendChild(each2);  }  }  return element; } function defaultErrorComponentFactory({ children , ...properties }, key, error) {  const element = document.createElement("div");  const errorDetails = document.createElement("code");  const childContainer = document.createElement("div");  element.style.all = "unset";  element.style.display = "flex";  element.style.flexDirection = "column";  element.style.padding = "1.5em";  element.style.backgroundColor = "#f5a5a8";  element.style.color = "white";  element.style.fontFamily = '-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen-Sans,Ubuntu,Cantarell,"Helvetica Neue",sans-serif';  element.style.fontSize = "18px";  element.style.fontWeight = "400";  element.style.overflow = "auto";  element.innerHTML = `I'm sorry, there was an error when loading this part of the page \u{1F641} `;  let errorElementPart;  if (typeof key == "string") {  errorElementPart = `<${key} />`;  } else {  try {  errorElementPart = `<${key.prototype.constructor.name} />`;  } catch (error2) {  errorElementPart = `<${key} />`;  }  }  let errorJsonObject = {};  for (const [key2, value] of Object.entries(properties)){  try {  errorJsonObject[key2] = JSON.parse(JSON.stringify(value));  } catch (error2) {  errorJsonObject[key2] = `${value}`;  }  }  errorDetails.innerHTML = `tag: ${errorElementPart} properties: ${JSON.stringify(errorJsonObject)} error: ${error}`;  errorDetails.style.padding = "1em";  errorDetails.style.backgroundColor = "#161b22";  errorDetails.style.color = "#789896";  element.appendChild(errorDetails);  childContainer.style.all = "unset";  childContainer.style.display = "flex";  childContainer.style.flexDirection = "column";  childContainer.style.marginTop = "1.3em";  if (children instanceof Array) {  for (const [key2, value] of Object.entries(children)){  if (typeof each == "string") {  childContainer.appendChild(new window.Text(value));  } else if (value instanceof Node) {  childContainer.appendChild(value);  }  }  }  element.appendChild(childContainer);  return element; } function isConstructor(obj) {  return !!obj.prototype && !!obj.prototype.constructor.name; } const originalHead = document.head; Object.defineProperty(document, "head", {  set: (element)=>appendChildren(originalHead, ...element.childNodes)  ,  get: ()=>originalHead }); const html = new Elemental().html; const css = Elemental.css; const allTags = Elemental.allTags; var ElementalLibrary = {  Elemental,  html,  css,  allTags }; const htmlEventHandlers = new Set([  "onabort",  "onanimationcancel",  "onanimationend",  "onanimationiteration",  "onanimationstart",  "onauxclick",  "onblur",  "onerror",  "onfocus",  "oncancel",  "oncanplay",  "oncanplaythrough",  "onchange",  "onclick",  "onclose",  "oncontextmenu",  "oncuechange",  "ondblclick",  "ondrag",  "ondragend",  "ondragenter",  "ondragleave",  "ondragover",  "ondragstart",  "ondrop",  "ondurationchange",  "onemptied",  "onended",  "onformdata",  "ongotpointercapture",  "oninput",  "oninvalid",  "onkeydown",  "onkeypress",  "onkeyup",  "onload",  "onloadeddata",  "onloadedmetadata",  "onloadend",  "onloadstart",  "onlostpointercapture",  "onmousedown",  "onmouseenter",  "onmouseleave",  "onmousemove",  "onmouseout",  "onmouseover",  "onmouseup",  "onmousewheel",  "onwheel",  "onpause",  "onplay",  "onplaying",  "onpointerdown",  "onpointermove",  "onpointerup",  "onpointercancel",  "onpointerover",  "onpointerout",  "onpointerenter",  "onpointerleave",  "onpointerlockchange",  "onpointerlockerror",  "onprogress",  "onratechange",  "onreset",  "onresize",  "onscroll",  "onsecuritypolicyviolation",  "onseeked",  "onseeking",  "onselect",  "onselectstart",  "onselectionchange",  "onshow",  "onslotchange",  "onstalled",  "onsubmit",  "onsuspend",  "ontimeupdate",  "onvolumechange",  "ontouchcancel",  "ontouchend",  "ontouchmove",  "ontouchstart",  "ontransitioncancel",  "ontransitionend",  "ontransitionrun",  "ontransitionstart",  "onwaiting" ]); const fixedAttributes = new Set([  "accept",  "accept-charset",  "accesskey",  "action",  "align",  "allow",  "alt",  "async",  "autocapitalize",  "autocomplete",  "autofocus",  "autoplay",  "background",  "bgcolor",  "border",  "buffered",  "capture",  "challenge",  "charset",  "checked",  "cite",  "class",  "code",  "codebase",  "color",  "cols",  "colspan",  "content",  "contenteditable",  "contextmenu",  "controls",  "coords",  "crossorigin",  "csp",  "data",  "datetime",  "decoding",  "default",  "defer",  "dir",  "dirname",  "disabled",  "download",  "draggable",  "enctype",  "enterkeyhint",  "for",  "form",  "formaction",  "formenctype",  "formmethod",  "formnovalidate",  "formtarget",  "headers",  "height",  "hidden",  "high",  "href",  "hreflang",  "http-equiv",  "icon",  "id",  "importance",  "integrity",  "intrinsicsize",  "inputmode",  "ismap",  "itemprop",  "keytype",  "kind",  "label",  "lang",  "language",  "loading",  "list",  "loop",  "low",  "manifest",  "max",  "maxlength",  "minlength",  "media",  "method",  "min",  "multiple",  "muted",  "name",  "novalidate",  "open",  "optimum",  "pattern",  "ping",  "placeholder",  "poster",  "preload",  "radiogroup",  "readonly",  "referrerpolicy",  "rel",  "required",  "reversed",  "rows",  "rowspan",  "sandbox",  "scope",  "scoped",  "selected",  "shape",  "size",  "sizes",  "slot",  "span",  "spellcheck",  "src",  "srcdoc",  "srclang",  "srcset",  "start",  "step",  "style",  "summary",  "tabindex",  "target",  "title",  "translate",  "type",  "usemap",  "value",  "width",  "wrap",  ...htmlEventHandlers ]); const isAnHtmlAttribute = (string)=>{  if (fixedAttributes.has(string)) {  return true;  } else if (string.startsWith("data-")) {  return true;  }  return false; }; const cssHmtlOverlap = new Set([  "width",  "height",  "background",  "border",  "color" ]); const splitHtmlCssAttributes = (object)=>{  const htmlAttributes = {};  const cssAttributes = {};  for (const [key, value] of Object.entries(object)){  if (cssHmtlOverlap.has(key)) {  htmlAttributes[key] = value;  cssAttributes[key] = value;  } else if (isAnHtmlAttribute(key)) {  htmlAttributes[key] = value;  } else {  cssAttributes[key] = value;  }  }  return [  htmlAttributes,  cssAttributes  ]; }; const computeDirection = (row, column, reverse)=>{  const output = row ? "row" : "column";  if (!reverse) {  return output;  } else {  return `${output}-reverse`;  } }; const humanPositionToCssPosition = (humanPosition)=>{  if (humanPosition === "relativeToParent") {  return "absolute";  } else if (humanPosition === "relativeToSelf") {  return "relative";  } else if (humanPosition === "relativeToWindow") {  return "fixed";  } else if (humanPosition === "sticky") {  return "sticky";  } else if (typeof humanPosition === "string") {  console.warn(`positionSelf needs to be one of [ 'relativeToParent', 'relativeToSelf', 'relativeToWindow', 'sticky' ] but instead it was: '${humanPosition}'`);  }  return void 0; }; const humanPositionToCssFlexbox = (humanWord)=>{  if (humanWord.match(/^(top|left)$/i)) {  return "flex-start";  } else if (humanWord.match(/^(bottom|right)$/i)) {  return "flex-end";  } else {  return humanWord;  } }; const columnAlignment = (horizontalAlignment, verticalAlignment, innerAlignment, wrap)=>{  if (!wrap) {  return {  justifyContent: verticalAlignment,  alignItems: horizontalAlignment  };  } else {  return {  justifyContent: verticalAlignment,  alignItems: innerAlignment,  alignContent: horizontalAlignment  };  } }; const rowAlignment = (horizontalAlignment, verticalAlignment, innerAlignment, wrap)=>{  if (!wrap) {  return {  justifyContent: horizontalAlignment,  alignItems: verticalAlignment  };  } else {  return {  justifyContent: horizontalAlignment,  alignItems: innerAlignment,  alignContent: verticalAlignment  };  } }; const computeFlexAlignmentAttributes = (directionIsRow, horizontalAlignment, verticalAlignment, innerAlignment, wrap)=>{  horizontalAlignment = humanPositionToCssFlexbox(horizontalAlignment);  verticalAlignment = humanPositionToCssFlexbox(verticalAlignment);  if (directionIsRow) {  return rowAlignment(horizontalAlignment, verticalAlignment, innerAlignment, wrap);  } else {  return columnAlignment(horizontalAlignment, verticalAlignment, innerAlignment, wrap);  } }; const setProperties = (element, properties)=>{  for (const [key, value] of Object.entries(properties)){  try {  const kebabCase = key.replace(/(?<=[a-z])([A-Z])(?=[a-z])/g, (each)=>`-${each.toLowerCase()}`  );  element.setAttribute(kebabCase, value);  } catch (error) {}  element[key] = value;  } }; const elementSymbol = Symbol.for("element"); function appendChildren1(element, ...children) {  for (const each of children){  if (typeof each == "string") {  element.appendChild(new window.Text(each));  } else if (each == null) {  element.appendChild(new window.Text(""));  } else if (!(each instanceof Object)) {  element.appendChild(new window.Text(`${each}`));  } else if (each[elementSymbol]) {  element.appendChild(each[elementSymbol]);  } else if (each instanceof Node) {  element.appendChild(each);  } else if (each instanceof Array) {  appendChildren1(element, ...each);  } else if (each instanceof Function) {  appendChildren1(element, each());  } else if (each instanceof Promise) {  const elementPromise = each;  const placeholder = elementPromise.placeholder || document.createElement("div");  setTimeout(async ()=>placeholder.replaceWith(await elementPromise)  , 0);  element.appendChild(placeholder);  } else if (each != null && each instanceof Object) {  element.appendChild(each);  }  }  return element; } var ContainerLibrary = ({ row , column , reverse , wrap , positionSelf ="relativeToSelf" , verticalAlignment ="top" , horizontalAlignment ="left" , innerAlignment ="center" , textWrapAlignment , children , ...props })=>{  const [htmlAttributes, cssAttributes] = splitHtmlCssAttributes(props);  const element = document.createElement("div");  Object.assign(element.style, {  position: humanPositionToCssPosition(positionSelf) || "relative",  display: "flex",  flexDirection: computeDirection(row, column, reverse),  flexWrap: wrap === "reverse" ? "wrap-reverse" : wrap && "wrap",  textAlign: textWrapAlignment || horizontalAlignment,  ...computeFlexAlignmentAttributes(row, horizontalAlignment, verticalAlignment, innerAlignment, wrap),  ...cssAttributes  });  setProperties(element, {  name: "positioner",  ...htmlAttributes  });  appendChildren1(element, children);  return element; }; return [ElementalLibrary, ContainerLibrary]})()
        // const { Elemental } = ElementalLibrary
        
        // import { Elemental } from "https://deno.land/x/elementalist@0.5.34/main/deno.js?code"
        
        // 
        // animations
        // 
        const [ fadeIn, fadeOut ] = [
            [
                [
                    { offset: 0.0, opacity: 0, },
                    { offset: 0.1, opacity: 0, },
                    { offset: 1.0, opacity: 1, },
                ], {
                    duration: 1000,
                    easing: 'ease-out',
                    iterations: 1
                }
            ],
            [
                [
                    { offset: 0.0, opacity: 1, },
                    { offset: 0.1, opacity: 1, },
                    { offset: 1.0, opacity: 0, },
                ], {
                    duration: 1000,
                    easing: 'ease-out',
                    iterations: 1
                }
            ],
        ]
        // 
        // tools
        // 
                class StopCallingListener {
                    constructor({minDelay, callback,}) {
                        this.callback = callback
                        this.minDelay = minDelay
                        this.timeoutId = null
                    }
                    call(func) {
                        console.log(`here`)
                        clearTimeout(this.timeoutId)
                        this.timeoutId = setTimeout(func||this.func, this.minDelay)
                    }
                }
                const localStorageListener = (name,element)=>{
                    const localStorageName = `settings:${name}`
                    let value
                    try {
                        value = localStorage.getItem(localStorageName)
                    } catch (error) {
                        
                    }
                    if (value != null) {
                        element.value = value
                    }
                    return (event)=>{
                        localStorage.setItem(localStorageName, event.target.value)
                    }
                }
                const showError = (message)=>{
                    new Toastify({
                        text: message,
                        position: 'right',
                        backgroundColor: "#ef6c00",
                        gravity: "bottom",
                        duration: 8000,
                    }).showToast()
                }
                const postJson = ({ data = null, to = null }) =>
                    fetch(to, {
                        method: 'POST',
                        headers: {
                            'Accept': 'application/json',
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(data)
                    }).then(res=>res.text()).catch(error => {
                        showError(`${error}`)
                        console.error('Error on postJson:', error);
                    }).then((text)=>{
                        try {
                            return JSON.parse(text)
                        } catch (error) {
                            showError(`Couldn't parse the response as JSON:\n${text}`)
                            throw error
                        }
                    })
                
                function mergeStyles(element, style) {
                    if (style) {
                        const helper = html`<div style=${style}/>`
                        const theyreActuallyKeys = Object.values(helper.style) 
                        for (const key of theyreActuallyKeys) {
                            element.style[key] = helper.style[key]
                        }
                    }
                }
                function removeAllChildElements(parentElement) {
                    while (parentElement.firstChild) {
                        parentElement.removeChild(parentElement.firstChild);
                    }
                }
                const helperElement = document.createElement("div")
                helperElement.setAttribute("note", "STUFF WILL BREAK IF YOU DELETE ME")
                helperElement.setAttribute("style", "position: fixed; top: 0; left: 0;")
                window.addEventListener("load", ()=>document.body.prepend(helperElement))
                const askForFiles = async ()=>{
                    return new Promise((resolve, reject)=>{
                        let value = null
                        let waitValue
                        let hasResolved = false
                        const cleanResolve = (returnValue)=>{
                            value = returnValue
                            if (hasResolved) {
                                return
                            }
                            if (!waitValue && returnValue.length == 0){
                                waitValue = setTimeout(()=>{
                                    if (!hasResolved) {
                                        hasResolved = true
                                        resolve(value)
                                    }
                                }, 200)
                            } else {
                                clearTimeout(waitValue)
                                hasResolved = true
                                resolve(value)
                            }
                            
                            try {
                                window.removeEventListener("focus", listener)
                                helperElement.removeChild(filePicker)
                            } catch (error) {
                                
                            }
                        }
                        const listener = ()=>cleanResolve([])
                        window.addEventListener("focus", listener)
                        let filePicker = html`<input
                            type="file"
                            onInput=${event=>{ cleanResolve(event.target.files) }}
                            onBlur=${event=>{ cleanResolve([]) }}
                            hidden
                            />`
                        helperElement.appendChild(filePicker)
                        filePicker.click()
                    })
                }
        // 
        // Custom elements
        // 
            const nullFunc = ()=>0
            const addDynamicStylerFlags = (element, flagKeys) => {
                element.dynamicStyler = element.dynamicStyler||nullFunc
                for (const [attribute, positiveEvent, negativeEvent] of flagKeys) {
                    element.addEventListener(positiveEvent, ()=>{
                        element[attribute] = true
                        element.dynamicStyler(element)
                    })
                    element.addEventListener(negativeEvent, ()=>{
                        element[attribute] = false
                        element.dynamicStyler(element)
                    })
                }
            }
            const Draggable = ({ children, persistentId, x, y, initX, initY }) => {
                const localStorageId = persistentId && `$draggable:${persistentId}`
                let element
                const wrapper = html`
                    <div style="">
                        ${element = html`
                            <div
                                style="background: whitesmoke; box-shadow: 0 4px 5px 0 rgba(0,0,0,0.14), 0 1px 10px 0 rgba(0,0,0,0.12), 0 2px 4px -1px rgba(0,0,0,0.3); color: black; position: absolute; top: -1rem; right: -1rem; --size: 2rem; width:  var(--size); height: var(--size);min-width:  var(--size); min-height: var(--size); border-radius: 5rem; border: 3px solid rgb(0,0,0,0.5);"
                                >
                            </div>
                        `}
                        ${children}
                    </div>
                `
                if (persistentId) {
                    x = initX
                    y = initY
                    // load whereever it was previously
                    try {
                        // assign "top", and "left"
                        Object.assign(
                            wrapper.style,
                            JSON.parse(storageObject[localStorageId]),
                        )
                    } catch (error) {
                        console.debug(`error is:`,error)
                        // just means it hasn't been saved yet
                    }
                }
                let isDragging = false;
                let offset = { x: 0, y: 0, };

                wrapper.style.position = 'fixed';
                wrapper.style.top = x
                wrapper.style.left = y

                element.addEventListener('mouseover', (e) => {
                    wrapper.style.cursor = 'grabbing'
                })
                element.addEventListener('mouseout', (e) => {
                    wrapper.style.cursor = null
                })
                element.addEventListener('mousedown', (e) => {
                    isDragging = true
                    
                    // Calculate the offset between mouse click and the top-left corner of the element
                    offset = {
                        x: e.clientX - wrapper.getBoundingClientRect().left,
                        y: e.clientY - wrapper.getBoundingClientRect().top
                    }

                    // Set cursor style to indicate dragging
                    wrapper.style.cursor = 'grabbing';
                });

                document.addEventListener('mousemove', (e) => {
                    if (isDragging) {
                        // Update element position based on mouse movement
                        wrapper.style.left = e.clientX - offset.x + 'px';
                        wrapper.style.top = e.clientY - offset.y + 'px';
                    }
                });

                document.addEventListener('mouseup', () => {
                    if (isDragging) {
                        if (localStorageId) {
                            storageObject[localStorageId] = `{"top":${JSON.stringify(wrapper.style.top)},"left":${JSON.stringify(wrapper.style.left)}}`
                        }
                        isDragging = false;
                        // Reset cursor style
                        wrapper.style.cursor = 'grab';
                    }
                });
                
                return wrapper
            }
            const Button = ({ style, children, ...other})=>{
                const before = html`
                    <span
                        style=${`
                            position: absolute;
                            top: 0;
                            bottom: 0;
                            left: 0;
                            right: 0;
                            background-color: rgb(var(--pure-material-onprimary-rgb, 255, 255, 255));
                            opacity: 0;
                            transition: opacity 0.2s;
                        `}
                        />
                `
                addDynamicStylerFlags(
                    before,
                    [
                        ['isHovered', 'mouseover', 'mouseout'],
                        ['isFocused', 'focus', 'blur'],
                    ]
                )
                const after = html`<span
                    style=${`
                        position: absolute;
                        left: 50%;
                        top: 50%;
                        border-radius: 50%;
                        padding: 50%;
                        width: 32px; /* Safari */
                        height: 32px; /* Safari */
                        background-color: rgb(var(--pure-material-onprimary-rgb, 255, 255, 255));
                        opacity: 0;
                        transform: translate(-50%, -50%) scale(1);
                        transition: opacity 1s, transform 0.5s;
                    `}
                    />`
                const helper = html`<button style=${style} />`
                const element = html`
                    <button
                        type="button"
                        style="${`
                            position: relative;
                            display: inline-block;
                            box-sizing: border-box;
                            border: none;
                            border-radius: 4px;
                            padding: 0 16px;
                            min-width: 64px;
                            height: 36px;
                            vertical-align: middle;
                            text-align: center;
                            text-overflow: ellipsis;
                            text-transform: uppercase;
                            color: rgb(var(--pure-material-onprimary-rgb, 255, 255, 255));
                            background-color: rgb(var(--pure-material-primary-rgb, 33, 150, 243));
                            box-shadow: 0 3px 1px -2px rgba(0, 0, 0, 0.2), 0 2px 2px 0 rgba(0, 0, 0, 0.14), 0 1px 5px 0 rgba(0, 0, 0, 0.12);
                            font-family: var(--pure-material-font, "Roboto", "Segoe UI", BlinkMacSystemFont, system-ui, -apple-system);
                            font-size: 14px;
                            font-weight: 500;
                            line-height: 36px;
                            overflow: hidden;
                            outline: none;
                            cursor: pointer;
                            transition: box-shadow 0.2s;
                            min-height: 2.5rem;
                        `}"
                        ...${other}
                        >
                            ${before}
                            ${children}
                            ${after}
                    </button>
                `
                mergeStyles(element, style)
                addDynamicStylerFlags(
                    element,
                    [
                        ['isHovered', 'mouseover', 'mouseout'],
                        ['isFocused', 'focus', 'blur'],
                        ['isActive', 'mousedown', 'mouseup'],
                    ]
                )
                element.dynamicStyler = (element)=>{
                    if (element.isActive) {
                        after.style.opacity = 0.32;
                        after.style.transform = `translate(-50%, -50%) scale(0)`;
                        after.style.transition = `transform 0s`;
                    } else { 
                        after.style.opacity = 0;
                        after.style.transform = `translate(-50%, -50%) scale(1)`;
                        after.style.transition = `opacity 1s, transform 0.5s`;
                    }

                    if (element.isHovered || element.isFocused) {
                        element.style.boxShadow = `0 2px 4px -1px rgba(0, 0, 0, 0.2), 0 4px 5px 0 rgba(0, 0, 0, 0.14), 0 1px 10px 0 rgba(0, 0, 0, 0.12)`
                    } else {
                        element.style.boxShadow = `0 3px 1px -2px rgba(0, 0, 0, 0.2), 0 2px 2px 0 rgba(0, 0, 0, 0.14), 0 1px 5px 0 rgba(0, 0, 0, 0.12)`
                    }
                }
                before.dynamicStyler = (element)=>{
                    if (before.IsFocused && before.isHovered) {
                        before.style.opacity = 0.30
                    } else if (before.IsFocused) {
                        before.style.opacity = 0.24
                    } else if (before.isHovered) {
                        before.style.opacity = 0.08
                    } else {
                        before.style.opacity = 0
                    }
                }
                return element
            }
            
            const Grid = ({style, data, ...other})=> {
                const element = html`<div style=${style}  ...${other} />`
                window.grid = element
                element.grid = new gridjs.Grid({
                    columns: [],
                    data: [],
                }).render(element)
                element.updateData = (newData)=>{
                    removeAllChildElements(element)
                    setTimeout(()=>{
                        element.grid = new gridjs.Grid({columns: [], data:[],...newData }).render(element)
                        element.grid.forceRender()
                    }, 1000)
                }
                return element
            }
        // 
        // custom elements import
        // 
            let dynamicInputs
            let dateTimeInput
            const { html } = window.Elemental({
                Container: ContainerLibrary,
                Button,
                Grid,
                Draggable,
                UploadFileButton({style, backendEndpoint, responseHandler, children}) {
                    return html`<Button
                        style=${style}
                        onClick=${
                            (event)=>{
                                askForFiles().then((files)=>{
                                    if (files.length > 0) {
                                        const file = files[0];
                                        
                                        // Create a FormData object to send the file
                                        const formData = new FormData()
                                        formData.append('file', file)

                                        // Replace 'your-backend-endpoint' with the actual backend endpoint
                                        // Use the Fetch API to send the file to the backend
                                        fetch(backendEndpoint, {
                                            method: 'POST',
                                            body: formData
                                        })
                                        .then(response => response.json())
                                        .then((data => {
                                            console.log('File uploaded successfully:', data);
                                            responseHandler(data)
                                        }))
                                        .catch(error => {
                                            showError(`${error}`)
                                            console.error('Error uploading file:', error);
                                        })
                                    }
                                })
                            }
                        }
                        >
                            ${children}
                    </Button>`
                }
            })
    
    // 
    // 
    // Main Code
    // 
    // 
    document.body = html`
        <body font-size=15px min-height=100vh min-width=100vw background="var(--soft-gray-gradient)">
            <Draggable persistentId="BeatriceMurphy" >
                <iframe id="myIframe" src="/Users/jeffhykin/repos/primient/main/evaluations.ignore.matlab_1/create_baysian_ridge_model/scatter_plot.html" width="600" height="400"></iframe>
            </Draggable>
        </body>
    `
    document.body.animate(...fadeIn)
</script>
</html>