#!/usr/bin/env sh
"\"",`$(echo --% ' |out-null)" >$null;function :{};function dv{<#${/*'>/dev/null )` 2>/dev/null;dv() { #>
echo "1.41.3"; : --% ' |out-null <#'; }; version="$(dv)"; deno="$HOME/.deno/$version/bin/deno"; if [ -x "$deno" ]; then  exec "$deno" run -q -A --no-lock "$0" "$@";  elif [ -f "$deno" ]; then  chmod +x "$deno" && exec "$deno" run -q -A --no-lock "$0" "$@";  fi; bin_dir="$HOME/.deno/$version/bin"; exe="$bin_dir/deno"; has () { command -v "$1" >/dev/null; } ;  if ! has unzip; then if ! has apt-get; then  has brew && brew install unzip; else  if [ "$(whoami)" = "root" ]; then  apt-get install unzip -y; elif has sudo; then  echo "Can I install unzip for you? (its required for this command to work) ";read ANSWER;echo;  if [ "$ANSWER" = "y" ] || [ "$ANSWER" = "yes" ] || [ "$ANSWER" = "Y" ]; then  sudo apt-get install unzip -y; fi; elif has doas; then  echo "Can I install unzip for you? (its required for this command to work) ";read ANSWER;echo;  if [ "$ANSWER" = "y" ] || [ "$ANSWER" = "yes" ] || [ "$ANSWER" = "Y" ]; then  doas apt-get install unzip -y; fi; fi;  fi;  fi;  if ! has unzip; then  echo ""; echo "So I couldn't find an 'unzip' command"; echo "And I tried to auto install it, but it seems that failed"; echo "(This script needs unzip and either curl or wget)"; echo "Please install the unzip command manually then re-run this script"; exit 1;  fi;  repo="denoland/deno"; if [ "$OS" = "Windows_NT" ]; then target="x86_64-pc-windows-msvc"; else :;  case $(uname -sm) in "Darwin x86_64") target="x86_64-apple-darwin" ;; "Darwin arm64") target="aarch64-apple-darwin" ;; "Linux aarch64") repo="LukeChannings/deno-arm64" target="linux-arm64" ;; "Linux armhf") echo "deno sadly doesn't support 32-bit ARM. Please check your hardware and possibly install a 64-bit operating system." exit 1 ;; *) target="x86_64-unknown-linux-gnu" ;; esac; fi; deno_uri="https://github.com/$repo/releases/download/v$version/deno-$target.zip"; exe="$bin_dir/deno"; if [ ! -d "$bin_dir" ]; then mkdir -p "$bin_dir"; fi;  if ! curl --fail --location --progress-bar --output "$exe.zip" "$deno_uri"; then if ! wget --output-document="$exe.zip" "$deno_uri"; then echo "Howdy! I looked for the 'curl' and for 'wget' commands but I didn't see either of them. Please install one of them, otherwise I have no way to install the missing deno version needed to run this code"; exit 1; fi; fi; unzip -d "$bin_dir" -o "$exe.zip"; chmod +x "$exe"; rm "$exe.zip"; exec "$deno" run -q -A --no-lock "$0" "$@"; #>}; $DenoInstall = "${HOME}/.deno/$(dv)"; $BinDir = "$DenoInstall/bin"; $DenoExe = "$BinDir/deno.exe"; if (-not(Test-Path -Path "$DenoExe" -PathType Leaf)) { $DenoZip = "$BinDir/deno.zip"; $DenoUri = "https://github.com/denoland/deno/releases/download/v$(dv)/deno-x86_64-pc-windows-msvc.zip";  [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;  if (!(Test-Path $BinDir)) { New-Item $BinDir -ItemType Directory | Out-Null; };  Function Test-CommandExists { Param ($command); $oldPreference = $ErrorActionPreference; $ErrorActionPreference = "stop"; try {if(Get-Command "$command"){RETURN $true}} Catch {Write-Host "$command does not exist"; RETURN $false}; Finally {$ErrorActionPreference=$oldPreference}; };  if (Test-CommandExists curl) { curl -Lo $DenoZip $DenoUri; } else { curl.exe -Lo $DenoZip $DenoUri; };  if (Test-CommandExists curl) { tar xf $DenoZip -C $BinDir; } else { tar -Lo $DenoZip $DenoUri; };  Remove-Item $DenoZip;  $User = [EnvironmentVariableTarget]::User; $Path = [Environment]::GetEnvironmentVariable('Path', $User); if (!(";$Path;".ToLower() -like "*;$BinDir;*".ToLower())) { [Environment]::SetEnvironmentVariable('Path', "$Path;$BinDir", $User); $Env:Path += ";$BinDir"; } }; & "$DenoExe" run -q -A --no-lock "$PSCommandPath" @args; Exit $LastExitCode; <# 
# */0}`;
import { Command, EnumType } from "https://deno.land/x/cliffy@v1.0.0-rc.3/command/mod.ts"
import { TerminalSpinner } from "https://deno.land/x/spinners@v1.1.2/mod.ts"
import { zip, enumerate, count, permute, combinations, wrapAroundGet } from "https://deno.land/x/good@1.5.1.0/array.js"
// import { FileSystem } from "https://deno.land/x/quickr@0.6.51/main/file_system.js"
import { Console, red, lightRed, yellow, green, cyan, dim, bold, clearAnsiStylesFrom } from "https://deno.land/x/quickr@0.6.56/main/console.js"
import { run, Out, Stdout, Stderr, returnAsString } from "https://deno.land/x/quickr@0.6.56/main/run.js"
import { capitalize, indent, toCamelCase, digitsToEnglishArray, toPascalCase, toKebabCase, toSnakeCase, toScreamingtoKebabCase, toScreamingtoSnakeCase, toRepresentation, toString, regex, findAll, iterativelyFindAll, escapeRegexMatch, escapeRegexReplace, extractFirst, isValidIdentifier, removeCommonPrefix, didYouMean } from "https://deno.land/x/good@1.5.1.0/string.js"
import { FileSystem } from "https://deno.land/x/quickr@0.6.56/main/file_system.js"
import * as yaml from "https://deno.land/std@0.168.0/encoding/yaml.ts"

import { selectOne } from "https://esm.sh/gh/jeff-hykin/nix_version_search_cli@c1aa88e/tools/input_tools.js"

export const nixStoreHashPattern = /[0123456789abcdfghijklmnpqrsvwxyz]{32}/

export const jsStringToNixString = (string)=>{
    return `"${string.replace(/\$\{|[\\"]/g, '\\$&').replace(/\u0000/g, '\\0')}"`
}
export const listNixPackages =  async ()=>{
    const packageList = await run`nix --extra-experimental-features nix-command profile list --json ${Stdout(returnAsString)}`
    const elements = JSON.parse(packageList).elements
    for (const [index, each] of enumerate(elements)) {
        each.Index = index
    }
    return elements
}

let hasFlakesEnabledString
export const checkIfFlakesEnabled = async ({cacheFolder})=>{
    // TODO: real check is `$HOME/.local/state/nix/profiles/profile/manifest.nix` => not flakes
    //                     `$HOME/.local/state/nix/profiles/profile/manifest.json` => yes flakes
    if (!hasFlakesEnabledString) {
        // 
        // flakes check
        // 
        const flakesCheckPath = `${cacheFolder}/has_flakes_enabled.check.json`
        hasFlakesEnabledString = FileSystem.sync.read(flakesCheckPath)
        if (hasFlakesEnabledString == null) {
            console.warn(`\n${cyan`❄️`} Checking if you use flakes...`)
            console.warn(dim`- (this will only run once)`)
            try {
                const result = await run`nix --extra-experimental-features nix-command profile list ${Stdout(returnAsString)} ${Stderr(null)}`
                hasFlakesEnabledString = !!result.match(/^Flake attribute: /m)
            } catch (error) {
                hasFlakesEnabledString = false
            }
            if (hasFlakesEnabledString) {
                console.warn(`${dim`- Okay looks like you do use flakes!`} ${cyan`❄️`}`)
            } else {
                console.warn(`${dim`- Okay looks like you dont use flakes`} ${red`X`}`)
            }
            console.warn(`${dim`- Saving this preference to disk at:\n    `}${yellow(JSON.stringify(flakesCheckPath))}`)
            hasFlakesEnabledString = JSON.stringify(hasFlakesEnabledString)
            console.warn(`\n`)
            FileSystem.sync.write({
                data: hasFlakesEnabledString,
                path: flakesCheckPath,
            })
        }
    }
    return JSON.parse(hasFlakesEnabledString)
}

function packageEntryToNames(packageEntry) {
    const names = []
    if (typeof packageEntry.attrPath == "string") {
        const components = packageEntry.attrPath.split(/\./g)
        if (components[0] == "packages" || components[0] == "legacyPackages") {
            const nameParts = components.slice(2,)
            if (nameParts.slice(-1)[0] == "default") {
                nameParts.pop()
            }
            if (nameParts.length > 0) {
                names.push(nameParts.join("."))
            }
        }
    }
    const storePaths = packageEntry.storePaths.filter(each=>each.length > 0)
    for (const eachStorePath of storePaths) {
        const [ folders, name, ext ] = FileSystem.pathPieces(eachStorePath)
        let match
        let prevFolderNameWasStore = false
        for (const each of folders) {
            if (prevFolderNameWasStore) {
                if (match = each.match(nixStoreHashPattern)) {
                    if (match.index == 0) {
                        // the +1 is for the dash
                        const derivationName = each.slice(match[0].length+1,)
                        if (derivationName) {
                            names.push(derivationName)
                        }
                    }
                }
                break
            }
            prevFolderNameWasStore = each == "store"
        }
    }
    return names
}

export async function remove({name, hasFlakesEnabled}) {
    if (!hasFlakesEnabled) {
        const isInteractive = !name
        if (!isInteractive) {
            const installCommand = `nix-env -e ${escapeNixString(name)}`
            console.log(dim`- running: ${installCommand}`)
            var {success} = await run`nix-env -e ${name}`
            if (success) {
                console.log(`\n - ✅ removed ${name}`)
            } else {
                console.error(`\n - ❌ there was an issue removing ${name}`)
            }
        } else {
            const packagesString = await run`nix-env -q --installed ${Stdout(returnAsString)}`
            const cancelOption = "[[cancel]]"
            const choice = await selectOne({
                message: "Which package would you like to uninstall?",
                showList: true,
                showInfo: false,
                options: packagesString.trim()+`\n${cancelOption}`.split("\n"),
            })
            if (choice == cancelOption) {
                return
            } else {
                await remove({name: choice, hasFlakesEnabled})
            }
        }
    } else {
        console.log(`Okay removing ${name}`)
        const packages = await listNixPackages()
        try {
            const uninstallList = []
            for (const eachPackage of packages) {
                const names = packageEntryToNames(eachPackage)
                if (names.some(each=>each.match(regex`${/^/}${name}${/\b/}`.ig))) {
                    uninstallList.push(eachPackage)
                }
            }
            for (const each of uninstallList) {
                if (each.Index!=null) {
                    try {
                        await run`nix --extra-experimental-features nix-command profile remove ${`${each.Index}`.trim()}`
                    } catch (error) {
                    }
                }
            }
        } catch (error) {
            console.warn(error)
        }
    }
}

export const removeExistingPackage = async ({urlOrPath, storePath, packages})=>{
    packages = packages || await listNixPackages()
    try {
        const uninstallList = []
        for (const eachPackage of packages) {
            const storePaths = packageEntry.storePaths.filter(each=>each.length > 0)
            const storePathMatches = storePaths.some(eachStorePath=>`${storePath}`.startsWith(eachStorePath))
            if (storePath && storePathMatches) {
                uninstallList.push(eachPackage)
            } else if (urlOrPath) {
                if (eachPackage.originalUrl == urlOrPath) {
                    uninstallList.push(eachPackage)
                }
            }
        }
        for (const each of uninstallList) {
            if (each.Index!=null) {
                try {
                    await run`nix --extra-experimental-features nix-command profile remove ${`${each.Index}`.trim()}`
                } catch (error) {
                }
            }
        }
    } catch (error) {
        console.warn(error)
    }
}

export async function install({hasFlakesEnabled, humanPackageSummary, urlOrPath, force, versionInfo}) {
    if (hasFlakesEnabled) {
        console.log(`Okay installing ${humanPackageSummary}`)
        let noProgressLoopDetection
        install: while (1) {
            let stderrOutput = ""
            const listener = {
                write(chunk) {
                    stderrOutput += (new TextDecoder()).decode(chunk)
                }
            }
            // try the install
            const installCommand = `nix --extra-experimental-features --extra-experimental-features flakes nix-command profile install ${jsStringToNixString(urlOrPath)}`
            const terminalSpinner = new TerminalSpinner()
            terminalSpinner.start(dim`- running: ${installCommand}`)
            var { success } = await run`nix --extra-experimental-features nix-command --extra-experimental-features flakes profile install ${urlOrPath} ${Stderr(Deno.stderr, listener)}`
            terminalSpinner.stop()
            if (noProgressLoopDetection == stderrOutput) {
                console.error(red(stderrOutput))
                console.error(`\n - ❌ there was an issue installing ${humanPackageSummary}`)
                throw Error(`Sorry, it looks like I was unable to install the package`)
            }
            noProgressLoopDetection = stderrOutput
            const conflictMatch = stderrOutput.match(/error: An existing package already provides the following file:(?:\w|\W)+?(?<existing>\/nix\/store\/.+)(?:\w|\W)+?This is the conflicting file from the new package:(?:\w|\W)+?(?<newPackage>\/nix\/store\/.+)(?:\w|\W)+?To remove the existing package:(?:\w|\W)+?(?<removeExisting>nix profile remove.+)(?:\w|\W)+?To prioritise the new package:(?:\w|\W)+?(?<prioritiseNew>nix profile install.+)(?:\w|\W)+?To prioritise the existing package:(?:\w|\W)+?(?<prioritiseExisting>nix profile install.+)/)
            if (conflictMatch) {
                const { existing, newPackage, removeExisting, prioritiseNew, prioritiseExisting } = conflictMatch.groups
                const [ folders, name, ext ] = FileSystem.pathPieces(existing)
                const simpleName = cyan(folders.slice(4,).join("/"))+cyan("/")+green(name+ext)
                clearScreen()
                const packages = await listNixPackages()
                
                if (force) {
                    const urlOrPath = (removeExisting.slice(("nix --extra-experimental-features nix-command profile remove ").length).match(/(.+?)#/)||"")[1]
                    if (removeExisting) {
                        await removeExistingPackage({urlOrPath, storePath: existing, packages})
                    }
                    continue install
                } else {
                    console.log(bold`Looks like there was a conflict:`)
                    console.log(`    The install adds: ${simpleName}`)
                    console.log(`    Which already exists from:\n        ${yellow((removeExisting||"").trim().slice(("nix --extra-experimental-features nix-command profile remove ").length)||existing)}`)
                    console.log(``)
                    const uninstallOption = "uninstall: remove the old package, install the one you just picked"
                    const newHigherPriorityOption = "higher: install the one you just picked with a higher priority"
                    const installAsLowerOption = "lower: install one you just picked, but have it be lower priority"
                    const choice = await selectOne({
                        message: "Choose an action:",
                        showList: true,
                        showInfo: false,
                        options: [
                            uninstallOption,
                            ...(prioritiseNew ? [newHigherPriorityOption] : []),
                            installAsLowerOption,
                            "cancel",
                        ],
                    })
                    if (choice == "cancel") {
                        throw Error(`cancel`)
                    } else if (choice == newHigherPriorityOption) {
                        await run(prioritiseNew.trim().split(/\s/g))
                    } else if (choice == installAsLowerOption) {
                        await run(prioritiseExisting.trim().split(/\s/g))
                    } else if (choice == uninstallOption) {
                        const urlOrPath = (removeExisting.slice(("nix --extra-experimental-features nix-command profile remove ").length).match(/(.+?)#/)||"")[1]
                        if (removeExisting) {
                            await removeExistingPackage({urlOrPath, storePath: existing, packages})
                        }
                    }
                    continue install
                }
                console.log(`\n - ✅ ${humanPackageSummary} should now be installed`)
            } else if (!success) {
                console.error(red(stderrOutput))
                console.error(`\n - ❌ there was an issue installing ${humanPackageSummary}`)
                throw Error(`Sorry, it looks like I was unable to install the package`)
            } else {
                console.log(`\n - ✅ ${humanPackageSummary} should now be installed`)
            }
            break
        }
    } else {
        try {
            const installCommand = `nix-env -iA ${jsStringToNixString(versionInfo.attrPath)} -f ${jsStringToNixString(`https://github.com/NixOS/nixpkgs/archive/${versionInfo.hash}.tar.gz`)}`
            console.log(dim`- running: ${installCommand}`)
            var {success} = await run`nix-env -iA ${versionInfo.attrPath} -f ${`https://github.com/NixOS/nixpkgs/archive/${versionInfo.hash}.tar.gz`}`
            if (success) {
                console.log(`\n - ✅ ${versionInfo.attrPath}@${versionInfo.version} should now be installed`)
            } else {
                console.error(`\n - ❌ there was an issue installing ${versionInfo.attrPath}@${versionInfo.version}`)
            }
        } catch (error) {
            console.log(`error is:`,error)
        }
    }
}


// 
// wip needs more testing
// 
function nameToIndicies(name, packageInfo) {
    name = name.toLowerCase() // remove case sensitivity
    const packages = packageInfo.elements.map((each,index)=>[each,index])
    let attrNameIndicies = packages.filter(([each, index])=>each?.attrPath&&each.attrPath.toLowerCase().endsWith(`.${name}`)).map(([each,index])=>index)
    if (attrNameIndicies.length == 0) {
        const indices = []
        packages.reverse()
        for (const [each,index] of packages) {
            if (each?.storePaths) {
                const commonName = each.storePaths.map(each=>each.toLowerCase().slice(storePathBaseLength,)).sort((a,b)=>a.length-b.length)[0]
                if (commonName == name || commonName.startsWith(`${name}-`)) {
                    attrNameIndicies.push(index)
                }
            }
        }
    }
    return attrNameIndicies
}

const storePathBaseLength = ("/nix/store/9i7rbbhxi1nnqibla22s785svlngcnvw-").length

export async function agressiveRemove(name) {
    let deletedSomething = false 
    while (true) {
        const text = await run`nix --extra-experimental-features nix-command profile list --json ${Stdout(returnAsString)}`
        var packageInfo = JSON.parse(text)
        const indices = nameToIndicies(name, packageInfo)
        if (indices.length == 0){
            break
        }
        for (const each of indices) {
            console.log(`running: nix --extra-experimental-features nix-command profile remove ${each}`)
            await run`nix --extra-experimental-features nix-command profile remove ${`${each-0}`}`
            deletedSomething = true
        }
    }
    if (!deletedSomething) {
        const packages = packageInfo.elements.map((each,index)=>[each,index])
        packages.reverse()
        next_package: for (const [each,index] of packages) {
            if (each?.storePaths) {
                const commonName = each.storePaths.map(each=>each.slice(storePathBaseLength,)).sort((a,b)=>a.length-b.length)[0]
                let attrName = `${each?.attrName}`.split(".").slice(2,).join(".")
                if (attrName == "default") {
                    attrName = null
                } else if (attrName.startsWith("default.")) {
                    attrName = attrName.slice(("default.").length,)
                }
                let packageName = ""
                if (attrName && commonName) {
                    packageName = `${attrName} (aka ${commonName})`
                } else {
                    packageName = attrName || commonName
                }
                for (const eachPath of each?.storePaths) {
                    for (const eachBinPath of await FileSystem.listFilePathsIn(`${eachPath}/bin`)) {
                        if (FileSystem.basename(eachBinPath) == name) { 
                            console.log(`This package ${yellow(packageName)} contains ${green(name)} as an executable`)
                            if (await Console.askFor.yesNo(`Do you want to remove the package?`)) {
                                await run`nix --extra-experimental-features nix-command profile remove ${index-0}`
                                deletedSomething = true
                            }
                            continue next_package
                        }
                    }
                }
            }
        }
    }
    if (!deletedSomething) {
        console.log(`I didn't see anything with ${JSON.stringify(name)} as an attribute name, pname, or with an executable with that name`)
    }
}


await agressiveRemove(Deno.args[0])